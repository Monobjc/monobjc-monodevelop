//
// This file is part of Monobjc, a .NET/Objective-C bridge
// Copyright (C) 2007-2011 - Laurent Etiemble
//
// Monobjc is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// Monobjc is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Monobjc.  If not, see <http://www.gnu.org/licenses/>.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using MonoDevelop.Monobjc.Utilities;
using MonoDevelop.Projects.Dom;
using MonoDevelop.Projects.Dom.Parser;
using MonoDevelop.Core;

namespace MonoDevelop.Monobjc.Tracking
{
	public static class HeaderGenerator
	{
		public static IEnumerable<String> GenerateHeaders (MonobjcProject project, String folder)
		{
			IList<String> result = new List<String> ();
			ProjectResolver resolver = new ProjectResolver (project);
			IEnumerable<IType> types = resolver.GetAllClasses (true);
			foreach (IType type in types) {
				String file = GenerateHeader (project, resolver, type, folder);
				result.Add (file);
			}
			return result;
		}

		public static String GenerateHeader (MonobjcProject project, ProjectResolver resolver, IType type, String folder)
		{
			LoggingService.LogInfo("GenerateHeader " + type);
			
			ProjectDom projectDom = ProjectDomService.GetProjectDom(project);
			
			String typeName = GetTypeName (type);
			String baseTypeName = GetTypeName (projectDom.GetType(type.BaseType));
			//DomReturnType voidType = new DomReturnType("System.Void");
			
			// Collect outlets/actions
			IEnumerable<IProperty> properties = (from p in type.Properties
			                                     where p.IsPublic && AttributeHelper.HasAttribute (p, AttributeHelper.OBJECTIVE_C_IVAR)
			                                     select p);
			IEnumerable<IMethod> methods = (from m in type.Methods
			                                where m.IsPublic 
			                                && !m.IsStatic
			                                //&& m.ReturnType == voidType 
			                                && m.Parameters.Count == 1 
			                                && AttributeHelper.HasAttribute (m, AttributeHelper.OBJECTIVE_C_MESSAGE)
			                                select m);
			
			// Create the filename
			String file = Path.Combine (folder, typeName + ".h");
			
			StringBuilder builder = new StringBuilder ();
			builder.AppendLine("//");
			builder.AppendLine("// Generated by MonoDevelop Monobjc Addins");
			builder.AppendLine("//");
			builder.AppendLine("// Only wired actions or outlets will be processed");
			builder.AppendLine("//");
			
			// Add framework imports
			String[] frameworks = project.OSFrameworks.Split (';');
			foreach (String framework in frameworks) {
				builder.AppendFormat ("#import <{0}/{0}.h>", framework);
				builder.AppendLine();
			}
			
			// Add user-type imports (collect property types and methods parameters/return type)
			List<String> typesNames = new List<String>();
			//typesNames.AddRange(properties.Select(p => GetTypeName(p.ReturnType)));
			//typesNames.AddRange(methods.Select(m => GetTypeName(m.ReturnType)));
			//typesNames.AddRange(methods.SelectMany(m => m.Parameters).Select(p => GetTypeName(p.ReturnType)));
			//typesNames.Sort();
			foreach(String name in typesNames.Distinct()){
				builder.AppendFormat ("#import \"{0}.h\"", name);
				builder.AppendLine();
			}
			
			builder.AppendLine();
			
			// Output the interface declaration
			builder.AppendFormat("@interface {0} : {1} {{", typeName, baseTypeName);
			builder.AppendLine();
			
			// Output the outlets
			foreach(var property in properties) {
				IType propertyType = projectDom.GetType(property.ReturnType);
				if (propertyType.ClassType == ClassType.Class ||
				    propertyType.ClassType == ClassType.Interface) {
					builder.AppendFormat("\tIBOutlet {0} *{1};", propertyType.Name, property.Name);
				} else {
					builder.AppendFormat("\tIBOutlet {0} {1};", propertyType.Name, property.Name);
				}
				builder.AppendLine();
			}
			
			builder.AppendLine ("}");
			
			// Output the actions
			foreach(var method in methods) {
				//builder.AppendFormat("- (IBAction){0}:({1}) sender;", typeName, baseTypeName);
				//builder.AppendLine();
			}
			
			builder.AppendLine ();
			builder.AppendLine ("@end");
			
			LoggingService.LogInfo("Writing file " + file);
			Directory.CreateDirectory(Path.GetDirectoryName(file));
			File.WriteAllText(file, builder.ToString());
			
			return file;
		}

		private static String GetTypeName (IType type)
		{
			var value = AttributeHelper.GetAttributeValue (type, AttributeHelper.OBJECTIVE_C_CLASS);
			if (value == null) {
				value = AttributeHelper.GetAttributeValue (type, AttributeHelper.OBJECTIVE_C_PROTOCOL);
			}
			return value ?? type.Name;
		}
	}
}
